#include <iostream>
#include <windows.h>

using namespace std;

int main()
{
    setlocale(LC_ALL, "Russian");
    SetConsoleCP(1251); // Ввод с консоли в кодировке 1251
    SetConsoleOutputCP(1251);
    // вывод на экран сообщения об авторе программы в формате: фамилия, 
    // инициалы, номер группы, номер варианта;
    printf("\nРусаков А.М., БИСО-0x-25, 4 вариант");
    //     Вариант 4
    // Выполнить ввод с клавиатуры числа типа long.Выделить байты этого числа с 
    // использованием побитовых операций.
    // Получить две динамические переменные типа short: первая составлена из младшего и 
    // старшего байтов введенного числа, вторая – из оставшихся.
    // Вывести на экран двоичное представление полученных
    // динамических переменных.
    // Если N - й бит первого числа равен 1, то поменять во втором
    // числе местами старший и младший байты.
    // Вывести полученные числа на экран.

    // ввод исходных данных и вывод результатов в шестнадцатеричной 
    // системе счисления(беззнаковые целые числа);
    long data = 128 * 11234567; // ввод исходных данных
    //Тип long в C++ занимает 4 байта (32 бита). 
    printf("\nВвод исходных данных:\n");
    //scanf_s("%d", &data); // нужно раскоментить перед сдачей
    printf("%d\n", data);   // нужно закоментить перед сдачей

    // Получить две динамические переменные типа short: первая составлена из младшего и 
    // старшего байтов введенного числа, вторая – из оставшихся.
    // В языке C++ тип short занимает в памяти 2 байта (16 бит)
    short* var1 = new short;

    *var1 = ((data >> 24)*256 + data >> 0);

    short N = 5;  // тут задается N
    // N в диапазоне от 0 до 15 - так как 2 байта
    // Если N - й бит первого числа равен 1, то поменять во втором
    // числе местами старший и младший байты.
    // Вывести полученные числа на экран.
    short* var2 = new short;
    if (*var1<<N==1)
        *var2 = ((data >> 8) * 256 + data >> 16);
    else
        *var2 = ((data >> 16) * 256 + data >> 8);
   
    // макрос define для вывчленения байтов (можно сделать функцию, но лучше макрос)
    // найден здесь https://stackoverflow.com/questions/111928/is-there-a-printf-converter-to-print-in-binary-format
    // упрощен для РТУ МИРЭА
    // смысл в том что вместо X для BYTE_TO_BINARY(X) выводится 8 чисел '0' или '1' соответствующих передаваемму числу X в формате byte (типа byte)
    // '?' тернарный оператор ветвления - аналог IF для двух значений в удобном читабельном виде
    // выражени (byte) & 0x01 ? '1' : '0' можно переписать как if (((byte) & 0x01)==1) printf("1"); else printf("0");
    // это степени двойки 0x01=1  0x02=2  0x04=4 0x08=8  0x10=16 0x20=32 0x40=64 0x80=128
    // нужно для вычлинения битов
    #define BYTE_TO_BINARY(byte)  \
      ((byte) & 0x80 ? '1' : '0'), \
      ((byte) & 0x40 ? '1' : '0'), \
      ((byte) & 0x20 ? '1' : '0'), \
      ((byte) & 0x10 ? '1' : '0'), \
      ((byte) & 0x08 ? '1' : '0'), \
      ((byte) & 0x04 ? '1' : '0'), \
      ((byte) & 0x02 ? '1' : '0'), \
      ((byte) & 0x01 ? '1' : '0') 
    printf("Двоичный код исходного числа: %c%c%c%c%c%c%c%c:%c%c%c%c%c%c%c%c:%c%c%c%c%c%c%c%c:%c%c%c%c%c%c%c%c \n", \
        BYTE_TO_BINARY(data >> 24), BYTE_TO_BINARY(data >> 16), BYTE_TO_BINARY(data >> 8), BYTE_TO_BINARY(data >>0));
    printf("Двоичный код числа 1: %c%c%c%c%c%c%c%c:%c%c%c%c%c%c%c%c \n", \
        BYTE_TO_BINARY(*var1 >> 8), BYTE_TO_BINARY(*var1 >> 0));
    printf("Двоичный код числа 2: %c%c%c%c%c%c%c%c:%c%c%c%c%c%c%c%c \n", \
        BYTE_TO_BINARY(*var2 >> 8), BYTE_TO_BINARY(*var2 >> 0));

    printf("Шестнадцатиричный код исходного числа: %04x\n", data);
    printf("Шестнадцатиричный код числа 1: %04x\n", *var1);
    printf("Шестнадцатиричный код числа 2: %04x\n", *var2);

    printf("Десятичный код исходного числа: %d\n", data);
    printf("Десятичный код числа 1: %d\n", *var1);
    printf("Десятичный код числа 2: %d\n", *var2);
    delete var1;
    delete var2;
}

